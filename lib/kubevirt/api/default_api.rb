=begin
#KubeVirt API

#This is KubeVirt API an add-on for Kubernetes.

The version of the OpenAPI document: 1.0.0
Contact: kubevirt-dev@googlegroups.com
Generated by: https://openapi-generator.tech
Generator version: 7.12.0

=end

require 'cgi'

module Kubevirt
  class DefaultApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Create a MigrationPolicy object.
    # @param body [V1alpha1MigrationPolicy] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1MigrationPolicy]
    def create_migration_policy(body, opts = {})
      data, _status_code, _headers = create_migration_policy_with_http_info(body, opts)
      data
    end

    # Create a MigrationPolicy object.
    # @param body [V1alpha1MigrationPolicy] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1MigrationPolicy, Integer, Hash)>] V1alpha1MigrationPolicy data, response status code and response headers
    def create_migration_policy_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_migration_policy ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_migration_policy"
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1MigrationPolicy'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a KubeVirt object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1KubeVirt] 
    # @param [Hash] opts the optional parameters
    # @return [V1KubeVirt]
    def create_namespaced_kube_virt(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_kube_virt_with_http_info(namespace, body, opts)
      data
    end

    # Create a KubeVirt object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1KubeVirt] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1KubeVirt, Integer, Hash)>] V1KubeVirt data, response status code and response headers
    def create_namespaced_kube_virt_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_kube_virt ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_kube_virt"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirt'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachine] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachine]
    def create_namespaced_virtual_machine(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachine] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachine, Integer, Hash)>] V1VirtualMachine data, response status code and response headers
    def create_namespaced_virtual_machine_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachine'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineExport object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineExport] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineExport]
    def create_namespaced_virtual_machine_export(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_export_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineExport object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineExport] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineExport, Integer, Hash)>] V1beta1VirtualMachineExport data, response status code and response headers
    def create_namespaced_virtual_machine_export_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExport'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineInstance object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstance] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstance]
    def create_namespaced_virtual_machine_instance(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_instance_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineInstance object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstance] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstance, Integer, Hash)>] V1VirtualMachineInstance data, response status code and response headers
    def create_namespaced_virtual_machine_instance_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineInstanceMigration object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceMigration] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceMigration]
    def create_namespaced_virtual_machine_instance_migration(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_instance_migration_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineInstanceMigration object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceMigration] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceMigration, Integer, Hash)>] V1VirtualMachineInstanceMigration data, response status code and response headers
    def create_namespaced_virtual_machine_instance_migration_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigration'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineInstancePreset object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstancePreset] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstancePreset]
    def create_namespaced_virtual_machine_instance_preset(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_instance_preset_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineInstancePreset object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstancePreset] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstancePreset, Integer, Hash)>] V1VirtualMachineInstancePreset data, response status code and response headers
    def create_namespaced_virtual_machine_instance_preset_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePreset'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineInstanceReplicaSet object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceReplicaSet] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceReplicaSet]
    def create_namespaced_virtual_machine_instance_replica_set(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineInstanceReplicaSet object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceReplicaSet] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceReplicaSet, Integer, Hash)>] V1VirtualMachineInstanceReplicaSet data, response status code and response headers
    def create_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSet'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineInstancetype object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineInstancetype]
    def create_namespaced_virtual_machine_instancetype(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_instancetype_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineInstancetype object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineInstancetype, Integer, Hash)>] V1beta1VirtualMachineInstancetype data, response status code and response headers
    def create_namespaced_virtual_machine_instancetype_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachinePool object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1alpha1VirtualMachinePool] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1VirtualMachinePool]
    def create_namespaced_virtual_machine_pool(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_pool_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachinePool object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1alpha1VirtualMachinePool] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1VirtualMachinePool, Integer, Hash)>] V1alpha1VirtualMachinePool data, response status code and response headers
    def create_namespaced_virtual_machine_pool_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePool'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachinePreference object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachinePreference] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachinePreference]
    def create_namespaced_virtual_machine_preference(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_preference_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachinePreference object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachinePreference] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachinePreference, Integer, Hash)>] V1beta1VirtualMachinePreference data, response status code and response headers
    def create_namespaced_virtual_machine_preference_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineRestore object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineRestore] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineRestore]
    def create_namespaced_virtual_machine_restore(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_restore_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineRestore object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineRestore] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineRestore, Integer, Hash)>] V1beta1VirtualMachineRestore data, response status code and response headers
    def create_namespaced_virtual_machine_restore_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestore'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineSnapshot object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshot] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshot]
    def create_namespaced_virtual_machine_snapshot(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_snapshot_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineSnapshot object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshot] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshot, Integer, Hash)>] V1beta1VirtualMachineSnapshot data, response status code and response headers
    def create_namespaced_virtual_machine_snapshot_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshot'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineSnapshotContent object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshotContent] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshotContent]
    def create_namespaced_virtual_machine_snapshot_content(namespace, body, opts = {})
      data, _status_code, _headers = create_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, body, opts)
      data
    end

    # Create a VirtualMachineSnapshotContent object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshotContent] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshotContent, Integer, Hash)>] V1beta1VirtualMachineSnapshotContent data, response status code and response headers
    def create_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.create_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineClone object.
    # @param body [V1beta1VirtualMachineClone] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClone]
    def create_virtual_machine_clone(body, opts = {})
      data, _status_code, _headers = create_virtual_machine_clone_with_http_info(body, opts)
      data
    end

    # Create a VirtualMachineClone object.
    # @param body [V1beta1VirtualMachineClone] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClone, Integer, Hash)>] V1beta1VirtualMachineClone data, response status code and response headers
    def create_virtual_machine_clone_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_virtual_machine_clone ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_virtual_machine_clone"
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClone'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineClusterInstancetype object.
    # @param body [V1beta1VirtualMachineClusterInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterInstancetype]
    def create_virtual_machine_cluster_instancetype(body, opts = {})
      data, _status_code, _headers = create_virtual_machine_cluster_instancetype_with_http_info(body, opts)
      data
    end

    # Create a VirtualMachineClusterInstancetype object.
    # @param body [V1beta1VirtualMachineClusterInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterInstancetype, Integer, Hash)>] V1beta1VirtualMachineClusterInstancetype data, response status code and response headers
    def create_virtual_machine_cluster_instancetype_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_virtual_machine_cluster_instancetype ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_virtual_machine_cluster_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a VirtualMachineClusterPreference object.
    # @param body [V1beta1VirtualMachineClusterPreference] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterPreference]
    def create_virtual_machine_cluster_preference(body, opts = {})
      data, _status_code, _headers = create_virtual_machine_cluster_preference_with_http_info(body, opts)
      data
    end

    # Create a VirtualMachineClusterPreference object.
    # @param body [V1beta1VirtualMachineClusterPreference] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterPreference, Integer, Hash)>] V1beta1VirtualMachineClusterPreference data, response status code and response headers
    def create_virtual_machine_cluster_preference_with_http_info(body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.create_virtual_machine_cluster_preference ...'
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.create_virtual_machine_cluster_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterPreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.create_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#create_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of MigrationPolicy objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_migration_policy(opts = {})
      data, _status_code, _headers = delete_collection_migration_policy_with_http_info(opts)
      data
    end

    # Delete a collection of MigrationPolicy objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_migration_policy_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_migration_policy ...'
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of KubeVirt objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_kube_virt(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_kube_virt_with_http_info(opts)
      data
    end

    # Delete a collection of KubeVirt objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_kube_virt_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_kube_virt ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachine objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachine objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineExport objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_export(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_export_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineExport objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_export_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_export ...'
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineInstance objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_instance(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_instance_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineInstance objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_instance_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_instance ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineInstanceMigration objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_instance_migration(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_instance_migration_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineInstanceMigration objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_instance_migration_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_instance_migration ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineInstancePreset objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_instance_preset(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_instance_preset_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineInstancePreset objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_instance_preset_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_instance_preset ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineInstanceReplicaSet objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_instance_replica_set(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_instance_replica_set_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineInstanceReplicaSet objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_instance_replica_set_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_instance_replica_set ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_instancetype(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_instancetype_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_instancetype_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_instancetype ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachinePool objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_pool(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_pool_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachinePool objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_pool_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_pool ...'
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachinePreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_preference(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_preference_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachinePreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_preference_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_preference ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineRestore objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_restore(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_restore_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineRestore objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_restore_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_restore ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineSnapshot objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_snapshot(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_snapshot_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineSnapshot objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_snapshot_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_snapshot ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineSnapshotContent objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_namespaced_virtual_machine_snapshot_content(opts = {})
      data, _status_code, _headers = delete_collection_namespaced_virtual_machine_snapshot_content_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineSnapshotContent objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_namespaced_virtual_machine_snapshot_content_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_namespaced_virtual_machine_snapshot_content ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineClone objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_virtual_machine_clone(opts = {})
      data, _status_code, _headers = delete_collection_virtual_machine_clone_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineClone objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_virtual_machine_clone_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_virtual_machine_clone ...'
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineClusterInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_virtual_machine_cluster_instancetype(opts = {})
      data, _status_code, _headers = delete_collection_virtual_machine_cluster_instancetype_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineClusterInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_virtual_machine_cluster_instancetype_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_virtual_machine_cluster_instancetype ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a collection of VirtualMachineClusterPreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_collection_virtual_machine_cluster_preference(opts = {})
      data, _status_code, _headers = delete_collection_virtual_machine_cluster_preference_with_http_info(opts)
      data
    end

    # Delete a collection of VirtualMachineClusterPreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_collection_virtual_machine_cluster_preference_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_collection_virtual_machine_cluster_preference ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_collection_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_collection_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_migration_policy(name, body, opts = {})
      data, _status_code, _headers = delete_migration_policy_with_http_info(name, body, opts)
      data
    end

    # Delete a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_migration_policy_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_migration_policy ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_migration_policy"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_migration_policy"
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_kube_virt(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_kube_virt_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_kube_virt_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_kube_virt ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_kube_virt"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_kube_virt"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_export(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_instance(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_instance_migration(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_instance_preset(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_instance_replica_set(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_instancetype(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_pool(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_preference(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_restore(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_snapshot(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_namespaced_virtual_machine_snapshot_content(name, namespace, body, opts = {})
      data, _status_code, _headers = delete_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts)
      data
    end

    # Delete a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_virtual_machine_clone(name, body, opts = {})
      data, _status_code, _headers = delete_virtual_machine_clone_with_http_info(name, body, opts)
      data
    end

    # Delete a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_virtual_machine_clone_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_virtual_machine_clone ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_virtual_machine_clone"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_virtual_machine_clone"
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_virtual_machine_cluster_instancetype(name, body, opts = {})
      data, _status_code, _headers = delete_virtual_machine_cluster_instancetype_with_http_info(name, body, opts)
      data
    end

    # Delete a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_virtual_machine_cluster_instancetype_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_virtual_machine_cluster_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_virtual_machine_cluster_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_virtual_machine_cluster_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [K8sIoApimachineryPkgApisMetaV1Status]
    def delete_virtual_machine_cluster_preference(name, body, opts = {})
      data, _status_code, _headers = delete_virtual_machine_cluster_preference_with_http_info(name, body, opts)
      data
    end

    # Delete a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [K8sIoApimachineryPkgApisMetaV1DeleteOptions] 
    # @param [Hash] opts the optional parameters
    # @option opts [Integer] :grace_period_seconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
    # @option opts [Boolean] :orphan_dependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
    # @option opts [String] :propagation_policy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: &#39;Orphan&#39; - orphan the dependents; &#39;Background&#39; - allow the garbage collector to delete the dependents in the background; &#39;Foreground&#39; - a cascading policy that deletes all dependents in the foreground.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1Status, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1Status data, response status code and response headers
    def delete_virtual_machine_cluster_preference_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.delete_virtual_machine_cluster_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.delete_virtual_machine_cluster_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.delete_virtual_machine_cluster_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'gracePeriodSeconds'] = opts[:'grace_period_seconds'] if !opts[:'grace_period_seconds'].nil?
      query_params[:'orphanDependents'] = opts[:'orphan_dependents'] if !opts[:'orphan_dependents'].nil?
      query_params[:'propagationPolicy'] = opts[:'propagation_policy'] if !opts[:'propagation_policy'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1Status'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.delete_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#delete_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def func13(opts = {})
      func13_with_http_info(opts)
      nil
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def func13_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.func13 ...'
      end
      # resource path
      local_var_path = '/healthz'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.func13",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#func13\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def func6(opts = {})
      func6_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def func6_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.func6 ...'
      end
      # resource path
      local_var_path = '/openapi/v2'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.func6",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#func6\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_clone_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_clone_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_clone_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_clone_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_clone_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_clone_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_export_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_export_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_export_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_export_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_export_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_export_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_instancetype_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_instancetype_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_instancetype_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_instancetype_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_instancetype_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_instancetype_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API GroupList
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroupList]
    def get_api_group_list(opts = {})
      data, _status_code, _headers = get_api_group_list_with_http_info(opts)
      data
    end

    # Get a KubeVirt API GroupList
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroupList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroupList data, response status code and response headers
    def get_api_group_list_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_list ...'
      end
      # resource path
      local_var_path = '/apis'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroupList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_list",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_list\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_migrations_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_migrations_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_migrations_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_migrations_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_migrations_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_migrations_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_pool_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_pool_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_pool_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_pool_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_pool_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_pool_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def get_api_group_snapshot_kubevirt_io(opts = {})
      data, _status_code, _headers = get_api_group_snapshot_kubevirt_io_with_http_info(opts)
      data
    end

    # Get a KubeVirt API group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def get_api_group_snapshot_kubevirt_io_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_group_snapshot_kubevirt_io ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_group_snapshot_kubevirt_io",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_group_snapshot_kubevirt_io\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_clone_kubevirt_io_v1beta1(opts = {})
      data, _status_code, _headers = get_api_resources_clone_kubevirt_io_v1beta1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_clone_kubevirt_io_v1beta1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_clone_kubevirt_io_v1beta1 ...'
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_clone_kubevirt_io_v1beta1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_clone_kubevirt_io_v1beta1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_export_kubevirt_io_v1beta1(opts = {})
      data, _status_code, _headers = get_api_resources_export_kubevirt_io_v1beta1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_export_kubevirt_io_v1beta1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_export_kubevirt_io_v1beta1 ...'
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_export_kubevirt_io_v1beta1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_export_kubevirt_io_v1beta1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_instancetype_kubevirt_io_v1beta1(opts = {})
      data, _status_code, _headers = get_api_resources_instancetype_kubevirt_io_v1beta1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_instancetype_kubevirt_io_v1beta1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_instancetype_kubevirt_io_v1beta1 ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_instancetype_kubevirt_io_v1beta1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_instancetype_kubevirt_io_v1beta1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_kubevirt_io_v1(opts = {})
      data, _status_code, _headers = get_api_resources_kubevirt_io_v1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_kubevirt_io_v1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_kubevirt_io_v1 ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_kubevirt_io_v1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_kubevirt_io_v1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_migrations_kubevirt_io_v1alpha1(opts = {})
      data, _status_code, _headers = get_api_resources_migrations_kubevirt_io_v1alpha1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_migrations_kubevirt_io_v1alpha1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_migrations_kubevirt_io_v1alpha1 ...'
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_migrations_kubevirt_io_v1alpha1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_migrations_kubevirt_io_v1alpha1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_pool_kubevirt_io_v1alpha1(opts = {})
      data, _status_code, _headers = get_api_resources_pool_kubevirt_io_v1alpha1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_pool_kubevirt_io_v1alpha1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_pool_kubevirt_io_v1alpha1 ...'
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_pool_kubevirt_io_v1alpha1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_pool_kubevirt_io_v1alpha1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def get_api_resources_snapshot_kubevirt_io_v1beta1(opts = {})
      data, _status_code, _headers = get_api_resources_snapshot_kubevirt_io_v1beta1_with_http_info(opts)
      data
    end

    # Get KubeVirt API Resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def get_api_resources_snapshot_kubevirt_io_v1beta1_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_api_resources_snapshot_kubevirt_io_v1beta1 ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_api_resources_snapshot_kubevirt_io_v1beta1",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_api_resources_snapshot_kubevirt_io_v1beta1\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get KubeVirt API root paths
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1RootPaths]
    def get_root_paths(opts = {})
      data, _status_code, _headers = get_root_paths_with_http_info(opts)
      data
    end

    # Get KubeVirt API root paths
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1RootPaths, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1RootPaths data, response status code and response headers
    def get_root_paths_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.get_root_paths ...'
      end
      # resource path
      local_var_path = '/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1RootPaths'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.get_root_paths",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#get_root_paths\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # dump profiler results endpoint
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def handle_dump_profiler(opts = {})
      handle_dump_profiler_with_http_info(opts)
      nil
    end

    # dump profiler results endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def handle_dump_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.handle_dump_profiler ...'
      end
      # resource path
      local_var_path = '/dump-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.handle_dump_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#handle_dump_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # start profiler endpoint
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def handle_start_profiler(opts = {})
      handle_start_profiler_with_http_info(opts)
      nil
    end

    # start profiler endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def handle_start_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.handle_start_profiler ...'
      end
      # resource path
      local_var_path = '/start-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.handle_start_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#handle_start_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # stop profiler endpoint
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def handle_stop_profiler(opts = {})
      handle_stop_profiler_with_http_info(opts)
      nil
    end

    # stop profiler endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def handle_stop_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.handle_stop_profiler ...'
      end
      # resource path
      local_var_path = '/stop-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.handle_stop_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#handle_stop_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all KubeVirt objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1KubeVirtList]
    def list_kube_virt_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_kube_virt_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all KubeVirt objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1KubeVirtList, Integer, Hash)>] V1KubeVirtList data, response status code and response headers
    def list_kube_virt_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_kube_virt_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/kubevirt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirtList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_kube_virt_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_kube_virt_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of MigrationPolicy objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1alpha1MigrationPolicyList]
    def list_migration_policy(opts = {})
      data, _status_code, _headers = list_migration_policy_with_http_info(opts)
      data
    end

    # Get a list of MigrationPolicy objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1alpha1MigrationPolicyList, Integer, Hash)>] V1alpha1MigrationPolicyList data, response status code and response headers
    def list_migration_policy_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_migration_policy ...'
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1MigrationPolicyList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of KubeVirt objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1KubeVirtList]
    def list_namespaced_kube_virt(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_kube_virt_with_http_info(namespace, opts)
      data
    end

    # Get a list of KubeVirt objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1KubeVirtList, Integer, Hash)>] V1KubeVirtList data, response status code and response headers
    def list_namespaced_kube_virt_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_kube_virt ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirtList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachine objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineList]
    def list_namespaced_virtual_machine(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachine objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineList, Integer, Hash)>] V1VirtualMachineList data, response status code and response headers
    def list_namespaced_virtual_machine_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineExport objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineExportList]
    def list_namespaced_virtual_machine_export(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_export_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineExport objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineExportList, Integer, Hash)>] V1beta1VirtualMachineExportList data, response status code and response headers
    def list_namespaced_virtual_machine_export_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExportList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineInstance objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceList]
    def list_namespaced_virtual_machine_instance(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_instance_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineInstance objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceList, Integer, Hash)>] V1VirtualMachineInstanceList data, response status code and response headers
    def list_namespaced_virtual_machine_instance_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineInstanceMigration objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceMigrationList]
    def list_namespaced_virtual_machine_instance_migration(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_instance_migration_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineInstanceMigration objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceMigrationList, Integer, Hash)>] V1VirtualMachineInstanceMigrationList data, response status code and response headers
    def list_namespaced_virtual_machine_instance_migration_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigrationList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineInstancePreset objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstancePresetList]
    def list_namespaced_virtual_machine_instance_preset(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_instance_preset_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineInstancePreset objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstancePresetList, Integer, Hash)>] V1VirtualMachineInstancePresetList data, response status code and response headers
    def list_namespaced_virtual_machine_instance_preset_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePresetList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineInstanceReplicaSet objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceReplicaSetList]
    def list_namespaced_virtual_machine_instance_replica_set(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineInstanceReplicaSet objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceReplicaSetList, Integer, Hash)>] V1VirtualMachineInstanceReplicaSetList data, response status code and response headers
    def list_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSetList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineInstancetype objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineInstancetypeList]
    def list_namespaced_virtual_machine_instancetype(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_instancetype_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineInstancetype objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineInstancetypeList, Integer, Hash)>] V1beta1VirtualMachineInstancetypeList data, response status code and response headers
    def list_namespaced_virtual_machine_instancetype_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetypeList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachinePool objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1alpha1VirtualMachinePoolList]
    def list_namespaced_virtual_machine_pool(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_pool_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachinePool objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1alpha1VirtualMachinePoolList, Integer, Hash)>] V1alpha1VirtualMachinePoolList data, response status code and response headers
    def list_namespaced_virtual_machine_pool_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePoolList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachinePreference objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachinePreferenceList]
    def list_namespaced_virtual_machine_preference(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_preference_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachinePreference objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachinePreferenceList, Integer, Hash)>] V1beta1VirtualMachinePreferenceList data, response status code and response headers
    def list_namespaced_virtual_machine_preference_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreferenceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineRestore objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineRestoreList]
    def list_namespaced_virtual_machine_restore(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_restore_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineRestore objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineRestoreList, Integer, Hash)>] V1beta1VirtualMachineRestoreList data, response status code and response headers
    def list_namespaced_virtual_machine_restore_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestoreList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineSnapshot objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineSnapshotList]
    def list_namespaced_virtual_machine_snapshot(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_snapshot_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineSnapshot objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineSnapshotList, Integer, Hash)>] V1beta1VirtualMachineSnapshotList data, response status code and response headers
    def list_namespaced_virtual_machine_snapshot_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineSnapshotContent objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineSnapshotContentList]
    def list_namespaced_virtual_machine_snapshot_content(namespace, opts = {})
      data, _status_code, _headers = list_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, opts)
      data
    end

    # Get a list of VirtualMachineSnapshotContent objects.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineSnapshotContentList, Integer, Hash)>] V1beta1VirtualMachineSnapshotContentList data, response status code and response headers
    def list_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.list_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContentList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineClone objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineCloneList]
    def list_virtual_machine_clone(opts = {})
      data, _status_code, _headers = list_virtual_machine_clone_with_http_info(opts)
      data
    end

    # Get a list of VirtualMachineClone objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineCloneList, Integer, Hash)>] V1beta1VirtualMachineCloneList data, response status code and response headers
    def list_virtual_machine_clone_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_clone ...'
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineCloneList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineClusterInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineClusterInstancetypeList]
    def list_virtual_machine_cluster_instancetype(opts = {})
      data, _status_code, _headers = list_virtual_machine_cluster_instancetype_with_http_info(opts)
      data
    end

    # Get a list of VirtualMachineClusterInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineClusterInstancetypeList, Integer, Hash)>] V1beta1VirtualMachineClusterInstancetypeList data, response status code and response headers
    def list_virtual_machine_cluster_instancetype_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_cluster_instancetype ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterInstancetypeList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of VirtualMachineClusterPreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineClusterPreferenceList]
    def list_virtual_machine_cluster_preference(opts = {})
      data, _status_code, _headers = list_virtual_machine_cluster_preference_with_http_info(opts)
      data
    end

    # Get a list of VirtualMachineClusterPreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineClusterPreferenceList, Integer, Hash)>] V1beta1VirtualMachineClusterPreferenceList data, response status code and response headers
    def list_virtual_machine_cluster_preference_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_cluster_preference ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterPreferenceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineExport objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineExportList]
    def list_virtual_machine_export_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_export_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineExport objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineExportList, Integer, Hash)>] V1beta1VirtualMachineExportList data, response status code and response headers
    def list_virtual_machine_export_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_export_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/virtualmachineexports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExportList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_export_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_export_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachine objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineList]
    def list_virtual_machine_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachine objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineList, Integer, Hash)>] V1VirtualMachineList data, response status code and response headers
    def list_virtual_machine_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/virtualmachines'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineInstance objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceList]
    def list_virtual_machine_instance_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_instance_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineInstance objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceList, Integer, Hash)>] V1VirtualMachineInstanceList data, response status code and response headers
    def list_virtual_machine_instance_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_instance_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/virtualmachineinstances'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_instance_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_instance_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineInstanceMigration objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceMigrationList]
    def list_virtual_machine_instance_migration_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_instance_migration_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineInstanceMigration objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceMigrationList, Integer, Hash)>] V1VirtualMachineInstanceMigrationList data, response status code and response headers
    def list_virtual_machine_instance_migration_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_instance_migration_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/virtualmachineinstancemigrations'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigrationList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_instance_migration_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_instance_migration_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineInstancePreset objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstancePresetList]
    def list_virtual_machine_instance_preset_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_instance_preset_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineInstancePreset objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstancePresetList, Integer, Hash)>] V1VirtualMachineInstancePresetList data, response status code and response headers
    def list_virtual_machine_instance_preset_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_instance_preset_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/virtualmachineinstancepresets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePresetList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_instance_preset_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_instance_preset_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineInstanceReplicaSet objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1VirtualMachineInstanceReplicaSetList]
    def list_virtual_machine_instance_replica_set_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_instance_replica_set_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineInstanceReplicaSet objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1VirtualMachineInstanceReplicaSetList, Integer, Hash)>] V1VirtualMachineInstanceReplicaSetList data, response status code and response headers
    def list_virtual_machine_instance_replica_set_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_instance_replica_set_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/virtualmachineinstancereplicasets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSetList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_instance_replica_set_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_instance_replica_set_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineInstancetypeList]
    def list_virtual_machine_instancetype_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_instancetype_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineInstancetype objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineInstancetypeList, Integer, Hash)>] V1beta1VirtualMachineInstancetypeList data, response status code and response headers
    def list_virtual_machine_instancetype_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_instancetype_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetypeList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_instancetype_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_instancetype_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachinePool objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1alpha1VirtualMachinePoolList]
    def list_virtual_machine_pool_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_pool_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachinePool objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1alpha1VirtualMachinePoolList, Integer, Hash)>] V1alpha1VirtualMachinePoolList data, response status code and response headers
    def list_virtual_machine_pool_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_pool_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/virtualmachinepools'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePoolList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_pool_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_pool_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachinePreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachinePreferenceList]
    def list_virtual_machine_preference_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_preference_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachinePreference objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachinePreferenceList, Integer, Hash)>] V1beta1VirtualMachinePreferenceList data, response status code and response headers
    def list_virtual_machine_preference_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_preference_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachinepreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreferenceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_preference_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_preference_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineRestore objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineRestoreList]
    def list_virtual_machine_restore_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_restore_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineRestore objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineRestoreList, Integer, Hash)>] V1beta1VirtualMachineRestoreList data, response status code and response headers
    def list_virtual_machine_restore_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_restore_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinerestores'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestoreList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_restore_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_restore_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineSnapshotContent objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineSnapshotContentList]
    def list_virtual_machine_snapshot_content_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_snapshot_content_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineSnapshotContent objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineSnapshotContentList, Integer, Hash)>] V1beta1VirtualMachineSnapshotContentList data, response status code and response headers
    def list_virtual_machine_snapshot_content_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_snapshot_content_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshotcontents'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContentList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_snapshot_content_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_snapshot_content_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a list of all VirtualMachineSnapshot objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [V1beta1VirtualMachineSnapshotList]
    def list_virtual_machine_snapshot_for_all_namespaces(opts = {})
      data, _status_code, _headers = list_virtual_machine_snapshot_for_all_namespaces_with_http_info(opts)
      data
    end

    # Get a list of all VirtualMachineSnapshot objects.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(V1beta1VirtualMachineSnapshotList, Integer, Hash)>] V1beta1VirtualMachineSnapshotList data, response status code and response headers
    def list_virtual_machine_snapshot_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.list_virtual_machine_snapshot_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshots'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.list_virtual_machine_snapshot_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#list_virtual_machine_snapshot_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1MigrationPolicy]
    def patch_migration_policy(name, body, opts = {})
      data, _status_code, _headers = patch_migration_policy_with_http_info(name, body, opts)
      data
    end

    # Patch a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1MigrationPolicy, Integer, Hash)>] V1alpha1MigrationPolicy data, response status code and response headers
    def patch_migration_policy_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_migration_policy ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_migration_policy"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_migration_policy"
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1MigrationPolicy'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1KubeVirt]
    def patch_namespaced_kube_virt(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_kube_virt_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1KubeVirt, Integer, Hash)>] V1KubeVirt data, response status code and response headers
    def patch_namespaced_kube_virt_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_kube_virt ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_kube_virt"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_kube_virt"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirt'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachine]
    def patch_namespaced_virtual_machine(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachine, Integer, Hash)>] V1VirtualMachine data, response status code and response headers
    def patch_namespaced_virtual_machine_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachine'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineExport]
    def patch_namespaced_virtual_machine_export(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineExport, Integer, Hash)>] V1beta1VirtualMachineExport data, response status code and response headers
    def patch_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExport'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstance]
    def patch_namespaced_virtual_machine_instance(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstance, Integer, Hash)>] V1VirtualMachineInstance data, response status code and response headers
    def patch_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceMigration]
    def patch_namespaced_virtual_machine_instance_migration(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceMigration, Integer, Hash)>] V1VirtualMachineInstanceMigration data, response status code and response headers
    def patch_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigration'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstancePreset]
    def patch_namespaced_virtual_machine_instance_preset(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstancePreset, Integer, Hash)>] V1VirtualMachineInstancePreset data, response status code and response headers
    def patch_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePreset'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceReplicaSet]
    def patch_namespaced_virtual_machine_instance_replica_set(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceReplicaSet, Integer, Hash)>] V1VirtualMachineInstanceReplicaSet data, response status code and response headers
    def patch_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSet'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineInstancetype]
    def patch_namespaced_virtual_machine_instancetype(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineInstancetype, Integer, Hash)>] V1beta1VirtualMachineInstancetype data, response status code and response headers
    def patch_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1VirtualMachinePool]
    def patch_namespaced_virtual_machine_pool(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1VirtualMachinePool, Integer, Hash)>] V1alpha1VirtualMachinePool data, response status code and response headers
    def patch_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePool'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachinePreference]
    def patch_namespaced_virtual_machine_preference(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachinePreference, Integer, Hash)>] V1beta1VirtualMachinePreference data, response status code and response headers
    def patch_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineRestore]
    def patch_namespaced_virtual_machine_restore(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineRestore, Integer, Hash)>] V1beta1VirtualMachineRestore data, response status code and response headers
    def patch_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestore'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshot]
    def patch_namespaced_virtual_machine_snapshot(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshot, Integer, Hash)>] V1beta1VirtualMachineSnapshot data, response status code and response headers
    def patch_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshot'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshotContent]
    def patch_namespaced_virtual_machine_snapshot_content(name, namespace, body, opts = {})
      data, _status_code, _headers = patch_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts)
      data
    end

    # Patch a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshotContent, Integer, Hash)>] V1beta1VirtualMachineSnapshotContent data, response status code and response headers
    def patch_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClone]
    def patch_virtual_machine_clone(name, body, opts = {})
      data, _status_code, _headers = patch_virtual_machine_clone_with_http_info(name, body, opts)
      data
    end

    # Patch a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClone, Integer, Hash)>] V1beta1VirtualMachineClone data, response status code and response headers
    def patch_virtual_machine_clone_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_virtual_machine_clone ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_virtual_machine_clone"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_virtual_machine_clone"
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClone'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterInstancetype]
    def patch_virtual_machine_cluster_instancetype(name, body, opts = {})
      data, _status_code, _headers = patch_virtual_machine_cluster_instancetype_with_http_info(name, body, opts)
      data
    end

    # Patch a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterInstancetype, Integer, Hash)>] V1beta1VirtualMachineClusterInstancetype data, response status code and response headers
    def patch_virtual_machine_cluster_instancetype_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_virtual_machine_cluster_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_virtual_machine_cluster_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_virtual_machine_cluster_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Patch a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterPreference]
    def patch_virtual_machine_cluster_preference(name, body, opts = {})
      data, _status_code, _headers = patch_virtual_machine_cluster_preference_with_http_info(name, body, opts)
      data
    end

    # Patch a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [Object] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterPreference, Integer, Hash)>] V1beta1VirtualMachineClusterPreference data, response status code and response headers
    def patch_virtual_machine_cluster_preference_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.patch_virtual_machine_cluster_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.patch_virtual_machine_cluster_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.patch_virtual_machine_cluster_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json-patch+json', 'application/merge-patch+json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterPreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.patch_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PATCH, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#patch_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1alpha1MigrationPolicy]
    def read_migration_policy(name, opts = {})
      data, _status_code, _headers = read_migration_policy_with_http_info(name, opts)
      data
    end

    # Get a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1alpha1MigrationPolicy, Integer, Hash)>] V1alpha1MigrationPolicy data, response status code and response headers
    def read_migration_policy_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_migration_policy ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_migration_policy"
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1MigrationPolicy'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1KubeVirt]
    def read_namespaced_kube_virt(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_kube_virt_with_http_info(name, namespace, opts)
      data
    end

    # Get a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1KubeVirt, Integer, Hash)>] V1KubeVirt data, response status code and response headers
    def read_namespaced_kube_virt_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_kube_virt ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_kube_virt"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirt'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1VirtualMachine]
    def read_namespaced_virtual_machine(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1VirtualMachine, Integer, Hash)>] V1VirtualMachine data, response status code and response headers
    def read_namespaced_virtual_machine_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachine'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineExport]
    def read_namespaced_virtual_machine_export(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_export_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineExport, Integer, Hash)>] V1beta1VirtualMachineExport data, response status code and response headers
    def read_namespaced_virtual_machine_export_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExport'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1VirtualMachineInstance]
    def read_namespaced_virtual_machine_instance(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_instance_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1VirtualMachineInstance, Integer, Hash)>] V1VirtualMachineInstance data, response status code and response headers
    def read_namespaced_virtual_machine_instance_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1VirtualMachineInstanceMigration]
    def read_namespaced_virtual_machine_instance_migration(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1VirtualMachineInstanceMigration, Integer, Hash)>] V1VirtualMachineInstanceMigration data, response status code and response headers
    def read_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigration'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1VirtualMachineInstancePreset]
    def read_namespaced_virtual_machine_instance_preset(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1VirtualMachineInstancePreset, Integer, Hash)>] V1VirtualMachineInstancePreset data, response status code and response headers
    def read_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePreset'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1VirtualMachineInstanceReplicaSet]
    def read_namespaced_virtual_machine_instance_replica_set(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1VirtualMachineInstanceReplicaSet, Integer, Hash)>] V1VirtualMachineInstanceReplicaSet data, response status code and response headers
    def read_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSet'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineInstancetype]
    def read_namespaced_virtual_machine_instancetype(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineInstancetype, Integer, Hash)>] V1beta1VirtualMachineInstancetype data, response status code and response headers
    def read_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1alpha1VirtualMachinePool]
    def read_namespaced_virtual_machine_pool(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_pool_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1alpha1VirtualMachinePool, Integer, Hash)>] V1alpha1VirtualMachinePool data, response status code and response headers
    def read_namespaced_virtual_machine_pool_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePool'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachinePreference]
    def read_namespaced_virtual_machine_preference(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_preference_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachinePreference, Integer, Hash)>] V1beta1VirtualMachinePreference data, response status code and response headers
    def read_namespaced_virtual_machine_preference_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineRestore]
    def read_namespaced_virtual_machine_restore(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_restore_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineRestore, Integer, Hash)>] V1beta1VirtualMachineRestore data, response status code and response headers
    def read_namespaced_virtual_machine_restore_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestore'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineSnapshot]
    def read_namespaced_virtual_machine_snapshot(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineSnapshot, Integer, Hash)>] V1beta1VirtualMachineSnapshot data, response status code and response headers
    def read_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshot'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineSnapshotContent]
    def read_namespaced_virtual_machine_snapshot_content(name, namespace, opts = {})
      data, _status_code, _headers = read_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, opts)
      data
    end

    # Get a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineSnapshotContent, Integer, Hash)>] V1beta1VirtualMachineSnapshotContent data, response status code and response headers
    def read_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.read_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineClone]
    def read_virtual_machine_clone(name, opts = {})
      data, _status_code, _headers = read_virtual_machine_clone_with_http_info(name, opts)
      data
    end

    # Get a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineClone, Integer, Hash)>] V1beta1VirtualMachineClone data, response status code and response headers
    def read_virtual_machine_clone_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_virtual_machine_clone ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_virtual_machine_clone"
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClone'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineClusterInstancetype]
    def read_virtual_machine_cluster_instancetype(name, opts = {})
      data, _status_code, _headers = read_virtual_machine_cluster_instancetype_with_http_info(name, opts)
      data
    end

    # Get a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineClusterInstancetype, Integer, Hash)>] V1beta1VirtualMachineClusterInstancetype data, response status code and response headers
    def read_virtual_machine_cluster_instancetype_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_virtual_machine_cluster_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_virtual_machine_cluster_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [V1beta1VirtualMachineClusterPreference]
    def read_virtual_machine_cluster_preference(name, opts = {})
      data, _status_code, _headers = read_virtual_machine_cluster_preference_with_http_info(name, opts)
      data
    end

    # Get a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :exact Should the export be exact. Exact export maintains cluster-specific fields like &#39;Namespace&#39;.
    # @option opts [Boolean] :export Should this value be exported. Export strips fields that a user can not specify.
    # @return [Array<(V1beta1VirtualMachineClusterPreference, Integer, Hash)>] V1beta1VirtualMachineClusterPreference data, response status code and response headers
    def read_virtual_machine_cluster_preference_with_http_info(name, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.read_virtual_machine_cluster_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.read_virtual_machine_cluster_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'exact'] = opts[:'exact'] if !opts[:'exact'].nil?
      query_params[:'export'] = opts[:'export'] if !opts[:'export'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml', 'application/json;stream=watch']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterPreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.read_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#read_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [V1alpha1MigrationPolicy] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1MigrationPolicy]
    def replace_migration_policy(name, body, opts = {})
      data, _status_code, _headers = replace_migration_policy_with_http_info(name, body, opts)
      data
    end

    # Update a MigrationPolicy object.
    # @param name [String] Name of the resource
    # @param body [V1alpha1MigrationPolicy] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1MigrationPolicy, Integer, Hash)>] V1alpha1MigrationPolicy data, response status code and response headers
    def replace_migration_policy_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_migration_policy ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_migration_policy"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_migration_policy"
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1MigrationPolicy'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_migration_policy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_migration_policy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1KubeVirt] 
    # @param [Hash] opts the optional parameters
    # @return [V1KubeVirt]
    def replace_namespaced_kube_virt(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_kube_virt_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a KubeVirt object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1KubeVirt] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1KubeVirt, Integer, Hash)>] V1KubeVirt data, response status code and response headers
    def replace_namespaced_kube_virt_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_kube_virt ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_kube_virt"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_kube_virt"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1KubeVirt'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachine] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachine]
    def replace_namespaced_virtual_machine(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachine] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachine, Integer, Hash)>] V1VirtualMachine data, response status code and response headers
    def replace_namespaced_virtual_machine_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachine'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineExport] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineExport]
    def replace_namespaced_virtual_machine_export(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineExport object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineExport] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineExport, Integer, Hash)>] V1beta1VirtualMachineExport data, response status code and response headers
    def replace_namespaced_virtual_machine_export_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_export"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineExport'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstance] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstance]
    def replace_namespaced_virtual_machine_instance(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstance] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstance, Integer, Hash)>] V1VirtualMachineInstance data, response status code and response headers
    def replace_namespaced_virtual_machine_instance_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_instance"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceMigration] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceMigration]
    def replace_namespaced_virtual_machine_instance_migration(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineInstanceMigration object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceMigration] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceMigration, Integer, Hash)>] V1VirtualMachineInstanceMigration data, response status code and response headers
    def replace_namespaced_virtual_machine_instance_migration_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_instance_migration"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceMigration'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstancePreset] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstancePreset]
    def replace_namespaced_virtual_machine_instance_preset(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineInstancePreset object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstancePreset] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstancePreset, Integer, Hash)>] V1VirtualMachineInstancePreset data, response status code and response headers
    def replace_namespaced_virtual_machine_instance_preset_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_instance_preset"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstancePreset'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceReplicaSet] 
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceReplicaSet]
    def replace_namespaced_virtual_machine_instance_replica_set(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineInstanceReplicaSet object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineInstanceReplicaSet] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceReplicaSet, Integer, Hash)>] V1VirtualMachineInstanceReplicaSet data, response status code and response headers
    def replace_namespaced_virtual_machine_instance_replica_set_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_instance_replica_set"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceReplicaSet'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineInstancetype]
    def replace_namespaced_virtual_machine_instancetype(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineInstancetype object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineInstancetype, Integer, Hash)>] V1beta1VirtualMachineInstancetype data, response status code and response headers
    def replace_namespaced_virtual_machine_instancetype_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1alpha1VirtualMachinePool] 
    # @param [Hash] opts the optional parameters
    # @return [V1alpha1VirtualMachinePool]
    def replace_namespaced_virtual_machine_pool(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachinePool object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1alpha1VirtualMachinePool] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1alpha1VirtualMachinePool, Integer, Hash)>] V1alpha1VirtualMachinePool data, response status code and response headers
    def replace_namespaced_virtual_machine_pool_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_pool"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1alpha1VirtualMachinePool'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachinePreference] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachinePreference]
    def replace_namespaced_virtual_machine_preference(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachinePreference object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachinePreference] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachinePreference, Integer, Hash)>] V1beta1VirtualMachinePreference data, response status code and response headers
    def replace_namespaced_virtual_machine_preference_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachinePreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineRestore] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineRestore]
    def replace_namespaced_virtual_machine_restore(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineRestore object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineRestore] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineRestore, Integer, Hash)>] V1beta1VirtualMachineRestore data, response status code and response headers
    def replace_namespaced_virtual_machine_restore_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_restore"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineRestore'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshot] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshot]
    def replace_namespaced_virtual_machine_snapshot(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineSnapshot object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshot] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshot, Integer, Hash)>] V1beta1VirtualMachineSnapshot data, response status code and response headers
    def replace_namespaced_virtual_machine_snapshot_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshot'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshotContent] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineSnapshotContent]
    def replace_namespaced_virtual_machine_snapshot_content(name, namespace, body, opts = {})
      data, _status_code, _headers = replace_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts)
      data
    end

    # Update a VirtualMachineSnapshotContent object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1beta1VirtualMachineSnapshotContent] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineSnapshotContent, Integer, Hash)>] V1beta1VirtualMachineSnapshotContent data, response status code and response headers
    def replace_namespaced_virtual_machine_snapshot_content_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot_content"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineSnapshotContent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClone] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClone]
    def replace_virtual_machine_clone(name, body, opts = {})
      data, _status_code, _headers = replace_virtual_machine_clone_with_http_info(name, body, opts)
      data
    end

    # Update a VirtualMachineClone object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClone] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClone, Integer, Hash)>] V1beta1VirtualMachineClone data, response status code and response headers
    def replace_virtual_machine_clone_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_virtual_machine_clone ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_virtual_machine_clone"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_virtual_machine_clone"
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/virtualmachineclones/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClone'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_virtual_machine_clone",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_virtual_machine_clone\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClusterInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterInstancetype]
    def replace_virtual_machine_cluster_instancetype(name, body, opts = {})
      data, _status_code, _headers = replace_virtual_machine_cluster_instancetype_with_http_info(name, body, opts)
      data
    end

    # Update a VirtualMachineClusterInstancetype object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClusterInstancetype] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterInstancetype, Integer, Hash)>] V1beta1VirtualMachineClusterInstancetype data, response status code and response headers
    def replace_virtual_machine_cluster_instancetype_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_virtual_machine_cluster_instancetype ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_virtual_machine_cluster_instancetype"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_virtual_machine_cluster_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterInstancetype'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_virtual_machine_cluster_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_virtual_machine_cluster_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClusterPreference] 
    # @param [Hash] opts the optional parameters
    # @return [V1beta1VirtualMachineClusterPreference]
    def replace_virtual_machine_cluster_preference(name, body, opts = {})
      data, _status_code, _headers = replace_virtual_machine_cluster_preference_with_http_info(name, body, opts)
      data
    end

    # Update a VirtualMachineClusterPreference object.
    # @param name [String] Name of the resource
    # @param body [V1beta1VirtualMachineClusterPreference] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1beta1VirtualMachineClusterPreference, Integer, Hash)>] V1beta1VirtualMachineClusterPreference data, response status code and response headers
    def replace_virtual_machine_cluster_preference_with_http_info(name, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.replace_virtual_machine_cluster_preference ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.replace_virtual_machine_cluster_preference"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.replace_virtual_machine_cluster_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'.sub('{' + 'name' + '}', CGI.escape(name.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json', 'application/yaml']) unless header_params['Accept']
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json', 'application/yaml'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'V1beta1VirtualMachineClusterPreference'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.replace_virtual_machine_cluster_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#replace_virtual_machine_cluster_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_check_health(opts = {})
      data, _status_code, _headers = v1_check_health_with_http_info(opts)
      data
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_check_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_check_health ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/healthz'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_check_health",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_check_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to a serial console on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1_console(name, namespace, opts = {})
      v1_console_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to a serial console on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1_console_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_console ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_console"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_console"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/console'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_console",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_console\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Expands instancetype and preference into the passed VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_expand_spec(namespace, opts = {})
      data, _status_code, _headers = v1_expand_spec_with_http_info(namespace, opts)
      data
    end

    # Expands instancetype and preference into the passed VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_expand_spec_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_expand_spec ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_expand_spec"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/expand-vm-spec'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_expand_spec",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_expand_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get list of active filesystems on guest machine via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceFileSystemList]
    def v1_filesystemlist(name, namespace, opts = {})
      data, _status_code, _headers = v1_filesystemlist_with_http_info(name, namespace, opts)
      data
    end

    # Get list of active filesystems on guest machine via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceFileSystemList, Integer, Hash)>] V1VirtualMachineInstanceFileSystemList data, response status code and response headers
    def v1_filesystemlist_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_filesystemlist ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_filesystemlist"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_filesystemlist"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceFileSystemList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_filesystemlist",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_filesystemlist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Freeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1FreezeUnfreezeTimeout] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_freeze(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_freeze_with_http_info(name, namespace, body, opts)
      data
    end

    # Freeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1FreezeUnfreezeTimeout] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_freeze_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_freeze ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_freeze"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_freeze"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_freeze"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/freeze'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_freeze",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_freeze\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API Group
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIGroup]
    def v1_get_sub_api_group(opts = {})
      data, _status_code, _headers = v1_get_sub_api_group_with_http_info(opts)
      data
    end

    # Get a KubeVirt API Group
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIGroup, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIGroup data, response status code and response headers
    def v1_get_sub_api_group_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_get_sub_api_group ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIGroup'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_get_sub_api_group",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_get_sub_api_group\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_guestfs(opts = {})
      data, _status_code, _headers = v1_guestfs_with_http_info(opts)
      data
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_guestfs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_guestfs ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/guestfs'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_guestfs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_guestfs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get guest agent os information
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceGuestAgentInfo]
    def v1_guestosinfo(name, namespace, opts = {})
      data, _status_code, _headers = v1_guestosinfo_with_http_info(name, namespace, opts)
      data
    end

    # Get guest agent os information
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceGuestAgentInfo, Integer, Hash)>] V1VirtualMachineInstanceGuestAgentInfo data, response status code and response headers
    def v1_guestosinfo_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_guestosinfo ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_guestosinfo"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_guestosinfo"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceGuestAgentInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_guestosinfo",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_guestosinfo\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Dumps a VirtualMachineInstance memory.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineMemoryDumpRequest] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_memory_dump(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_memory_dump_with_http_info(name, namespace, body, opts)
      data
    end

    # Dumps a VirtualMachineInstance memory.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineMemoryDumpRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_memory_dump_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_memory_dump ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_memory_dump"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_memory_dump"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_memory_dump"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/memorydump'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_memory_dump",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_memory_dump\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Migrate a running VirtualMachine to another node.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1MigrateOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_migrate(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_migrate_with_http_info(name, namespace, body, opts)
      data
    end

    # Migrate a running VirtualMachine to another node.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1MigrateOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_migrate_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_migrate ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_migrate"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_migrate"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_migrate"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/migrate'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_migrate",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_migrate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Pause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1PauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_pause(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_pause_with_http_info(name, namespace, body, opts)
      data
    end

    # Pause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1PauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_pause_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_pause ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_pause"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_pause"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_pause"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/pause'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_pause",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_pause\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove memory dump association.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_remove_memory_dump(name, namespace, opts = {})
      data, _status_code, _headers = v1_remove_memory_dump_with_http_info(name, namespace, opts)
      data
    end

    # Remove memory dump association.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_remove_memory_dump_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_remove_memory_dump ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_remove_memory_dump"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_remove_memory_dump"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removememorydump'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_remove_memory_dump",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_remove_memory_dump\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reset a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_reset(name, namespace, opts = {})
      data, _status_code, _headers = v1_reset_with_http_info(name, namespace, opts)
      data
    end

    # Reset a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_reset_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_reset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_reset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_reset"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/reset'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_reset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_reset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Restart a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1RestartOptions] :body 
    # @return [String]
    def v1_restart(name, namespace, opts = {})
      data, _status_code, _headers = v1_restart_with_http_info(name, namespace, opts)
      data
    end

    # Restart a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1RestartOptions] :body 
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_restart_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_restart ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_restart"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_restart"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/restart'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_restart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_restart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fetch SEV certificate chain from the node where Virtual Machine is scheduled
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1SEVPlatformInfo]
    def v1_sev_fetch_cert_chain(name, namespace, opts = {})
      data, _status_code, _headers = v1_sev_fetch_cert_chain_with_http_info(name, namespace, opts)
      data
    end

    # Fetch SEV certificate chain from the node where Virtual Machine is scheduled
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1SEVPlatformInfo, Integer, Hash)>] V1SEVPlatformInfo data, response status code and response headers
    def v1_sev_fetch_cert_chain_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_sev_fetch_cert_chain ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_sev_fetch_cert_chain"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_sev_fetch_cert_chain"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1SEVPlatformInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_sev_fetch_cert_chain",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_sev_fetch_cert_chain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Inject SEV launch secret into a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSecretOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_sev_inject_launch_secret(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_sev_inject_launch_secret_with_http_info(name, namespace, body, opts)
      data
    end

    # Inject SEV launch secret into a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSecretOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_sev_inject_launch_secret_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_sev_inject_launch_secret ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_sev_inject_launch_secret"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_sev_inject_launch_secret"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_sev_inject_launch_secret"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_sev_inject_launch_secret",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_sev_inject_launch_secret\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query SEV launch measurement from a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1SEVMeasurementInfo]
    def v1_sev_query_launch_measurement(name, namespace, opts = {})
      data, _status_code, _headers = v1_sev_query_launch_measurement_with_http_info(name, namespace, opts)
      data
    end

    # Query SEV launch measurement from a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1SEVMeasurementInfo, Integer, Hash)>] V1SEVMeasurementInfo data, response status code and response headers
    def v1_sev_query_launch_measurement_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_sev_query_launch_measurement ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_sev_query_launch_measurement"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_sev_query_launch_measurement"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1SEVMeasurementInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_sev_query_launch_measurement",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_sev_query_launch_measurement\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Setup SEV session parameters for a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSessionOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_sev_setup_session(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_sev_setup_session_with_http_info(name, namespace, body, opts)
      data
    end

    # Setup SEV session parameters for a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSessionOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_sev_setup_session_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_sev_setup_session ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_sev_setup_session"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_sev_setup_session"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_sev_setup_session"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_sev_setup_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_sev_setup_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Soft reboot a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_soft_reboot(name, namespace, opts = {})
      data, _status_code, _headers = v1_soft_reboot_with_http_info(name, namespace, opts)
      data
    end

    # Soft reboot a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_soft_reboot_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_soft_reboot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_soft_reboot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_soft_reboot"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_soft_reboot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_soft_reboot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Start a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1StartOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_start(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_start_with_http_info(name, namespace, body, opts)
      data
    end

    # Start a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1StartOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_start_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_start ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_start"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_start"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_start"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/start'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_start",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_start\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Stop a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1StopOptions] :body 
    # @return [String]
    def v1_stop(name, namespace, opts = {})
      data, _status_code, _headers = v1_stop_with_http_info(name, namespace, opts)
      data
    end

    # Stop a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1StopOptions] :body 
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_stop_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_stop ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_stop"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_stop"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/stop'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_stop",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_stop\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unfreeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_unfreeze(name, namespace, opts = {})
      data, _status_code, _headers = v1_unfreeze_with_http_info(name, namespace, opts)
      data
    end

    # Unfreeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_unfreeze_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_unfreeze ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_unfreeze"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_unfreeze"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_unfreeze",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_unfreeze\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unpause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1UnpauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1_unpause(name, namespace, body, opts = {})
      data, _status_code, _headers = v1_unpause_with_http_info(name, namespace, body, opts)
      data
    end

    # Unpause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1UnpauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1_unpause_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_unpause ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_unpause"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_unpause"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1_unpause"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unpause'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_unpause",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_unpause\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get list of active users via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceGuestOSUserList]
    def v1_userlist(name, namespace, opts = {})
      data, _status_code, _headers = v1_userlist_with_http_info(name, namespace, opts)
      data
    end

    # Get list of active users via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceGuestOSUserList, Integer, Hash)>] V1VirtualMachineInstanceGuestOSUserList data, response status code and response headers
    def v1_userlist_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_userlist ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_userlist"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_userlist"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/userlist'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceGuestOSUserList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_userlist",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_userlist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1_version(opts = {})
      v1_version_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1_version_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_version ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/version'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_version",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_version\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1_vnc(name, namespace, opts = {})
      v1_vnc_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1_vnc_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_vnc ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_vnc"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_vnc"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_vnc",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_vnc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a PNG VNC screenshot of the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :move_cursor Move the cursor on the VNC display to wake up the screen
    # @return [nil]
    def v1_vnc_screenshot(name, namespace, opts = {})
      v1_vnc_screenshot_with_http_info(name, namespace, opts)
      nil
    end

    # Get a PNG VNC screenshot of the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :move_cursor Move the cursor on the VNC display to wake up the screen
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1_vnc_screenshot_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_vnc_screenshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_vnc_screenshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_vnc_screenshot"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'moveCursor'] = opts[:'move_cursor'] if !opts[:'move_cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_vnc_screenshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_vnc_screenshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [Integer] The port which the VSOCK application listens to.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :tls Weather to request a TLS encrypted session from the VSOCK application.
    # @return [nil]
    def v1_vsock(name, namespace, port, opts = {})
      v1_vsock_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [Integer] The port which the VSOCK application listens to.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :tls Weather to request a TLS encrypted session from the VSOCK application.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1_vsock_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1_vsock ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1_vsock"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1_vsock"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1_vsock"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vsock'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'port'] = port
      query_params[:'tls'] = opts[:'tls'] if !opts[:'tls'].nil?

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1_vsock",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1_vsock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_check_health(opts = {})
      data, _status_code, _headers = v1alpha3_check_health_with_http_info(opts)
      data
    end

    # Health endpoint
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_check_health_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_check_health ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/healthz'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_check_health",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_check_health\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to a serial console on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3_console(name, namespace, opts = {})
      v1alpha3_console_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to a serial console on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3_console_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_console ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_console"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_console"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/console'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_console",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_console\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Expands instancetype and preference into the passed VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_expand_spec(namespace, opts = {})
      data, _status_code, _headers = v1alpha3_expand_spec_with_http_info(namespace, opts)
      data
    end

    # Expands instancetype and preference into the passed VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_expand_spec_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_expand_spec ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_expand_spec"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/expand-vm-spec'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_expand_spec",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_expand_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get list of active filesystems on guest machine via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceFileSystemList]
    def v1alpha3_filesystemlist(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_filesystemlist_with_http_info(name, namespace, opts)
      data
    end

    # Get list of active filesystems on guest machine via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceFileSystemList, Integer, Hash)>] V1VirtualMachineInstanceFileSystemList data, response status code and response headers
    def v1alpha3_filesystemlist_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_filesystemlist ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_filesystemlist"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_filesystemlist"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceFileSystemList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_filesystemlist",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_filesystemlist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Freeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1FreezeUnfreezeTimeout] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_freeze(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_freeze_with_http_info(name, namespace, body, opts)
      data
    end

    # Freeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1FreezeUnfreezeTimeout] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_freeze_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_freeze ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_freeze"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_freeze"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_freeze"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/freeze'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_freeze",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_freeze\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_guestfs(opts = {})
      data, _status_code, _headers = v1alpha3_guestfs_with_http_info(opts)
      data
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_guestfs_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_guestfs ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/guestfs'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_guestfs",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_guestfs\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get guest agent os information
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceGuestAgentInfo]
    def v1alpha3_guestosinfo(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_guestosinfo_with_http_info(name, namespace, opts)
      data
    end

    # Get guest agent os information
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceGuestAgentInfo, Integer, Hash)>] V1VirtualMachineInstanceGuestAgentInfo data, response status code and response headers
    def v1alpha3_guestosinfo_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_guestosinfo ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_guestosinfo"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_guestosinfo"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceGuestAgentInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_guestosinfo",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_guestosinfo\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Dumps a VirtualMachineInstance memory.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineMemoryDumpRequest] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_memory_dump(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_memory_dump_with_http_info(name, namespace, body, opts)
      data
    end

    # Dumps a VirtualMachineInstance memory.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1VirtualMachineMemoryDumpRequest] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_memory_dump_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_memory_dump ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_memory_dump"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_memory_dump"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_memory_dump"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/memorydump'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_memory_dump",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_memory_dump\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Migrate a running VirtualMachine to another node.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1MigrateOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_migrate(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_migrate_with_http_info(name, namespace, body, opts)
      data
    end

    # Migrate a running VirtualMachine to another node.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1MigrateOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_migrate_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_migrate ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_migrate"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_migrate"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_migrate"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/migrate'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_migrate",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_migrate\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Pause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1PauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_pause(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_pause_with_http_info(name, namespace, body, opts)
      data
    end

    # Pause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1PauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_pause_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_pause ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_pause"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_pause"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_pause"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/pause'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_pause",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_pause\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Remove memory dump association.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_remove_memory_dump(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_remove_memory_dump_with_http_info(name, namespace, opts)
      data
    end

    # Remove memory dump association.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_remove_memory_dump_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_remove_memory_dump ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_remove_memory_dump"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_remove_memory_dump"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removememorydump'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_remove_memory_dump",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_remove_memory_dump\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Reset a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_reset(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_reset_with_http_info(name, namespace, opts)
      data
    end

    # Reset a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_reset_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_reset ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_reset"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_reset"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/reset'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_reset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_reset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Restart a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1RestartOptions] :body 
    # @return [String]
    def v1alpha3_restart(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_restart_with_http_info(name, namespace, opts)
      data
    end

    # Restart a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1RestartOptions] :body 
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_restart_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_restart ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_restart"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_restart"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/restart'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_restart",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_restart\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Fetch SEV certificate chain from the node where Virtual Machine is scheduled
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1SEVPlatformInfo]
    def v1alpha3_sev_fetch_cert_chain(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_sev_fetch_cert_chain_with_http_info(name, namespace, opts)
      data
    end

    # Fetch SEV certificate chain from the node where Virtual Machine is scheduled
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1SEVPlatformInfo, Integer, Hash)>] V1SEVPlatformInfo data, response status code and response headers
    def v1alpha3_sev_fetch_cert_chain_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_sev_fetch_cert_chain ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_sev_fetch_cert_chain"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_sev_fetch_cert_chain"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1SEVPlatformInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_sev_fetch_cert_chain",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_sev_fetch_cert_chain\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Inject SEV launch secret into a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSecretOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_sev_inject_launch_secret(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_sev_inject_launch_secret_with_http_info(name, namespace, body, opts)
      data
    end

    # Inject SEV launch secret into a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSecretOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_sev_inject_launch_secret_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_sev_inject_launch_secret ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_sev_inject_launch_secret"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_sev_inject_launch_secret"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_sev_inject_launch_secret"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_sev_inject_launch_secret",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_sev_inject_launch_secret\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Query SEV launch measurement from a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1SEVMeasurementInfo]
    def v1alpha3_sev_query_launch_measurement(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_sev_query_launch_measurement_with_http_info(name, namespace, opts)
      data
    end

    # Query SEV launch measurement from a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1SEVMeasurementInfo, Integer, Hash)>] V1SEVMeasurementInfo data, response status code and response headers
    def v1alpha3_sev_query_launch_measurement_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_sev_query_launch_measurement ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_sev_query_launch_measurement"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_sev_query_launch_measurement"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1SEVMeasurementInfo'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_sev_query_launch_measurement",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_sev_query_launch_measurement\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Setup SEV session parameters for a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSessionOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_sev_setup_session(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_sev_setup_session_with_http_info(name, namespace, body, opts)
      data
    end

    # Setup SEV session parameters for a Virtual Machine
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1SEVSessionOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_sev_setup_session_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_sev_setup_session ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_sev_setup_session"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_sev_setup_session"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_sev_setup_session"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_sev_setup_session",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_sev_setup_session\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Soft reboot a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_soft_reboot(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_soft_reboot_with_http_info(name, namespace, opts)
      data
    end

    # Soft reboot a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_soft_reboot_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_soft_reboot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_soft_reboot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_soft_reboot"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_soft_reboot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_soft_reboot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Start a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1StartOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_start(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_start_with_http_info(name, namespace, body, opts)
      data
    end

    # Start a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1StartOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_start_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_start ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_start"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_start"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_start"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/start'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_start",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_start\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Stop a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1StopOptions] :body 
    # @return [String]
    def v1alpha3_stop(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_stop_with_http_info(name, namespace, opts)
      data
    end

    # Stop a VirtualMachine object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [V1StopOptions] :body 
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_stop_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_stop ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_stop"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_stop"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/stop'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(opts[:'body'])

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_stop",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_stop\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unfreeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_unfreeze(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_unfreeze_with_http_info(name, namespace, opts)
      data
    end

    # Unfreeze a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_unfreeze_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_unfreeze ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_unfreeze"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_unfreeze"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_unfreeze",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_unfreeze\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Unpause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1UnpauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3_unpause(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3_unpause_with_http_info(name, namespace, body, opts)
      data
    end

    # Unpause a VirtualMachineInstance object.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1UnpauseOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3_unpause_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_unpause ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_unpause"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_unpause"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3_unpause"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unpause'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_unpause",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_unpause\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get list of active users via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [V1VirtualMachineInstanceGuestOSUserList]
    def v1alpha3_userlist(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3_userlist_with_http_info(name, namespace, opts)
      data
    end

    # Get list of active users via guest agent
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(V1VirtualMachineInstanceGuestOSUserList, Integer, Hash)>] V1VirtualMachineInstanceGuestOSUserList data, response status code and response headers
    def v1alpha3_userlist_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_userlist ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_userlist"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_userlist"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/userlist'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'V1VirtualMachineInstanceGuestOSUserList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_userlist",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_userlist\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3_version(opts = {})
      v1alpha3_version_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3_version_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_version ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/version'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_version",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_version\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3_vnc(name, namespace, opts = {})
      v1alpha3_vnc_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3_vnc_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_vnc ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_vnc"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_vnc"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_vnc",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_vnc\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a PNG VNC screenshot of the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :move_cursor Move the cursor on the VNC display to wake up the screen
    # @return [nil]
    def v1alpha3_vnc_screenshot(name, namespace, opts = {})
      v1alpha3_vnc_screenshot_with_http_info(name, namespace, opts)
      nil
    end

    # Get a PNG VNC screenshot of the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :move_cursor Move the cursor on the VNC display to wake up the screen
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3_vnc_screenshot_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_vnc_screenshot ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_vnc_screenshot"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_vnc_screenshot"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'moveCursor'] = opts[:'move_cursor'] if !opts[:'move_cursor'].nil?

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_vnc_screenshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_vnc_screenshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [Integer] The port which the VSOCK application listens to.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :tls Weather to request a TLS encrypted session from the VSOCK application.
    # @return [nil]
    def v1alpha3_vsock(name, namespace, port, opts = {})
      v1alpha3_vsock_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [Integer] The port which the VSOCK application listens to.
    # @param [Hash] opts the optional parameters
    # @option opts [Boolean] :tls Weather to request a TLS encrypted session from the VSOCK application.
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3_vsock_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3_vsock ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3_vsock"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3_vsock"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1alpha3_vsock"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vsock'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'port'] = port
      query_params[:'tls'] = opts[:'tls'] if !opts[:'tls'].nil?

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3_vsock",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3_vsock\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3dump_cluster_profiler(opts = {})
      v1alpha3dump_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3dump_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3dump_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/dump-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3dump_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3dump_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def v1alpha3get_api_sub_resources(opts = {})
      data, _status_code, _headers = v1alpha3get_api_sub_resources_with_http_info(opts)
      data
    end

    # Get a KubeVirt API resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def v1alpha3get_api_sub_resources_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3get_api_sub_resources ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3get_api_sub_resources",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3get_api_sub_resources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3start_cluster_profiler(opts = {})
      v1alpha3start_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3start_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3start_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/start-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3start_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3start_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3stop_cluster_profiler(opts = {})
      v1alpha3stop_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3stop_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3stop_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/stop-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3stop_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3stop_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3usbredir(name, namespace, opts = {})
      v1alpha3usbredir_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3usbredir_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3usbredir ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3usbredir"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3usbredir"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3usbredir",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3usbredir\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a volume and disk to a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3vm_addvolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3vm_addvolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Add a volume and disk to a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3vm_addvolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vm_addvolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vm_addvolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vm_addvolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3vm_addvolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/addvolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vm_addvolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vm_addvolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get VirtualMachine object with expanded instancetype and preference.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3vm_expand_spec(name, namespace, opts = {})
      data, _status_code, _headers = v1alpha3vm_expand_spec_with_http_info(name, namespace, opts)
      data
    end

    # Get VirtualMachine object with expanded instancetype and preference.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3vm_expand_spec_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vm_expand_spec ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vm_expand_spec"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vm_expand_spec"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/expand-spec'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vm_expand_spec",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vm_expand_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3vm_port_forward(name, namespace, port, opts = {})
      v1alpha3vm_port_forward_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3vm_port_forward_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vm_port_forward ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vm_port_forward"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vm_port_forward"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1alpha3vm_port_forward"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vm_port_forward",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vm_port_forward\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3vm_port_forward_with_protocol(name, namespace, port, protocol, opts = {})
      v1alpha3vm_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts)
      nil
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3vm_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vm_port_forward_with_protocol ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vm_port_forward_with_protocol"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vm_port_forward_with_protocol"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1alpha3vm_port_forward_with_protocol"
      end
      # verify the required parameter 'protocol' is set
      if @api_client.config.client_side_validation && protocol.nil?
        fail ArgumentError, "Missing the required parameter 'protocol' when calling DefaultApi.v1alpha3vm_port_forward_with_protocol"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s)).sub('{' + 'protocol' + '}', CGI.escape(protocol.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vm_port_forward_with_protocol",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vm_port_forward_with_protocol\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Removes a volume and disk from a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3vm_removevolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3vm_removevolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Removes a volume and disk from a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3vm_removevolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vm_removevolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vm_removevolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vm_removevolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3vm_removevolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removevolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vm_removevolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vm_removevolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a volume and disk to a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3vmi_addvolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3vmi_addvolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Add a volume and disk to a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3vmi_addvolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vmi_addvolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vmi_addvolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vmi_addvolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3vmi_addvolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vmi_addvolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vmi_addvolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3vmi_port_forward(name, namespace, port, opts = {})
      v1alpha3vmi_port_forward_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3vmi_port_forward_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vmi_port_forward ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vmi_port_forward"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vmi_port_forward"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1alpha3vmi_port_forward"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vmi_port_forward",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vmi_port_forward\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1alpha3vmi_port_forward_with_protocol(name, namespace, port, protocol, opts = {})
      v1alpha3vmi_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts)
      nil
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1alpha3vmi_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vmi_port_forward_with_protocol ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1alpha3vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'protocol' is set
      if @api_client.config.client_side_validation && protocol.nil?
        fail ArgumentError, "Missing the required parameter 'protocol' when calling DefaultApi.v1alpha3vmi_port_forward_with_protocol"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s)).sub('{' + 'protocol' + '}', CGI.escape(protocol.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vmi_port_forward_with_protocol",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vmi_port_forward_with_protocol\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Removes a volume and disk from a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1alpha3vmi_removevolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1alpha3vmi_removevolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Removes a volume and disk from a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1alpha3vmi_removevolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1alpha3vmi_removevolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1alpha3vmi_removevolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1alpha3vmi_removevolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1alpha3vmi_removevolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1alpha3vmi_removevolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1alpha3vmi_removevolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1dump_cluster_profiler(opts = {})
      v1dump_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1dump_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1dump_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/dump-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1dump_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1dump_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get a KubeVirt API resources
    # @param [Hash] opts the optional parameters
    # @return [K8sIoApimachineryPkgApisMetaV1APIResourceList]
    def v1get_api_sub_resources(opts = {})
      data, _status_code, _headers = v1get_api_sub_resources_with_http_info(opts)
      data
    end

    # Get a KubeVirt API resources
    # @param [Hash] opts the optional parameters
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1APIResourceList, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1APIResourceList data, response status code and response headers
    def v1get_api_sub_resources_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1get_api_sub_resources ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1APIResourceList'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1get_api_sub_resources",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1get_api_sub_resources\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1start_cluster_profiler(opts = {})
      v1start_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1start_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1start_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/start-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1start_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1start_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1stop_cluster_profiler(opts = {})
      v1stop_cluster_profiler_with_http_info(opts)
      nil
    end

    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1stop_cluster_profiler_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1stop_cluster_profiler ...'
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/stop-cluster-profiler'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1stop_cluster_profiler",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1stop_cluster_profiler\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1usbredir(name, namespace, opts = {})
      v1usbredir_with_http_info(name, namespace, opts)
      nil
    end

    # Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1usbredir_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1usbredir ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1usbredir"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1usbredir"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1usbredir",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1usbredir\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a volume and disk to a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1vm_addvolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1vm_addvolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Add a volume and disk to a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1vm_addvolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vm_addvolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vm_addvolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vm_addvolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1vm_addvolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/addvolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vm_addvolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vm_addvolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get VirtualMachine object with expanded instancetype and preference.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1vm_expand_spec(name, namespace, opts = {})
      data, _status_code, _headers = v1vm_expand_spec_with_http_info(name, namespace, opts)
      data
    end

    # Get VirtualMachine object with expanded instancetype and preference.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1vm_expand_spec_with_http_info(name, namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vm_expand_spec ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vm_expand_spec"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vm_expand_spec"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/expand-spec'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vm_expand_spec",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vm_expand_spec\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1vm_port_forward(name, namespace, port, opts = {})
      v1vm_port_forward_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1vm_port_forward_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vm_port_forward ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vm_port_forward"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vm_port_forward"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1vm_port_forward"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vm_port_forward",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vm_port_forward\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1vm_port_forward_with_protocol(name, namespace, port, protocol, opts = {})
      v1vm_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts)
      nil
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1vm_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vm_port_forward_with_protocol ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vm_port_forward_with_protocol"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vm_port_forward_with_protocol"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1vm_port_forward_with_protocol"
      end
      # verify the required parameter 'protocol' is set
      if @api_client.config.client_side_validation && protocol.nil?
        fail ArgumentError, "Missing the required parameter 'protocol' when calling DefaultApi.v1vm_port_forward_with_protocol"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s)).sub('{' + 'protocol' + '}', CGI.escape(protocol.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vm_port_forward_with_protocol",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vm_port_forward_with_protocol\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Removes a volume and disk from a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1vm_removevolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1vm_removevolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Removes a volume and disk from a running Virtual Machine.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1vm_removevolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vm_removevolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vm_removevolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vm_removevolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1vm_removevolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removevolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vm_removevolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vm_removevolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a volume and disk to a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1vmi_addvolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1vmi_addvolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Add a volume and disk to a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1AddVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1vmi_addvolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vmi_addvolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vmi_addvolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vmi_addvolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1vmi_addvolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vmi_addvolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vmi_addvolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1vmi_port_forward(name, namespace, port, opts = {})
      v1vmi_port_forward_with_http_info(name, namespace, port, opts)
      nil
    end

    # Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1vmi_port_forward_with_http_info(name, namespace, port, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vmi_port_forward ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vmi_port_forward"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vmi_port_forward"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1vmi_port_forward"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vmi_port_forward",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vmi_port_forward\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def v1vmi_port_forward_with_protocol(name, namespace, port, protocol, opts = {})
      v1vmi_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts)
      nil
    end

    # Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param port [String] The target port for portforward on the VirtualMachineInstance.
    # @param protocol [String] The protocol for portforward on the VirtualMachineInstance.
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def v1vmi_port_forward_with_protocol_with_http_info(name, namespace, port, protocol, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vmi_port_forward_with_protocol ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'port' is set
      if @api_client.config.client_side_validation && port.nil?
        fail ArgumentError, "Missing the required parameter 'port' when calling DefaultApi.v1vmi_port_forward_with_protocol"
      end
      # verify the required parameter 'protocol' is set
      if @api_client.config.client_side_validation && protocol.nil?
        fail ArgumentError, "Missing the required parameter 'protocol' when calling DefaultApi.v1vmi_port_forward_with_protocol"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s)).sub('{' + 'port' + '}', CGI.escape(port.to_s)).sub('{' + 'protocol' + '}', CGI.escape(protocol.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vmi_port_forward_with_protocol",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vmi_port_forward_with_protocol\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Removes a volume and disk from a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [String]
    def v1vmi_removevolume(name, namespace, body, opts = {})
      data, _status_code, _headers = v1vmi_removevolume_with_http_info(name, namespace, body, opts)
      data
    end

    # Removes a volume and disk from a running Virtual Machine Instance
    # @param name [String] Name of the resource
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param body [V1RemoveVolumeOptions] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def v1vmi_removevolume_with_http_info(name, namespace, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.v1vmi_removevolume ...'
      end
      # verify the required parameter 'name' is set
      if @api_client.config.client_side_validation && name.nil?
        fail ArgumentError, "Missing the required parameter 'name' when calling DefaultApi.v1vmi_removevolume"
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.v1vmi_removevolume"
      end
      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling DefaultApi.v1vmi_removevolume"
      end
      # resource path
      local_var_path = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume'.sub('{' + 'name' + '}', CGI.escape(name.to_s)).sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['*/*']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.v1vmi_removevolume",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#v1vmi_removevolume\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a KubeVirtList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_kube_virt_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_kube_virt_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a KubeVirtList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_kube_virt_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_kube_virt_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/kubevirt'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_kube_virt_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_kube_virt_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a MigrationPolicyList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_migration_policy_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_migration_policy_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a MigrationPolicyList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_migration_policy_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_migration_policy_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/migrations.kubevirt.io/v1alpha1/watch/migrationpolicies'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_migration_policy_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_migration_policy_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a KubeVirt object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_kube_virt(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_kube_virt_with_http_info(namespace, opts)
      data
    end

    # Watch a KubeVirt object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_kube_virt_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_kube_virt ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_kube_virt"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/kubevirt'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_kube_virt",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_kube_virt\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachine object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachines'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineExport object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_export(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_export_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineExport object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_export_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_export ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_export"
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineexports'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_export",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_export\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstance object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_instance(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_instance_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineInstance object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_instance_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_instance ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_instance"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstances'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_instance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_instance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstanceMigration object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_instance_migration(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_instance_migration_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineInstanceMigration object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_instance_migration_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_instance_migration ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_instance_migration"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancemigrations'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_instance_migration",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_instance_migration\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstancePreset object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_instance_preset(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_instance_preset_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineInstancePreset object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_instance_preset_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_instance_preset ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_instance_preset"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancepresets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_instance_preset",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_instance_preset\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstanceReplicaSet object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_instance_replica_set(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineInstanceReplicaSet object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_instance_replica_set_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_instance_replica_set ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_instance_replica_set"
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancereplicasets'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_instance_replica_set",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_instance_replica_set\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstancetype object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_instancetype(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_instancetype_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineInstancetype object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_instancetype_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_instancetype ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_instancetype"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineinstancetypes'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_instancetype",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_instancetype\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachinePool object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_pool(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_pool_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachinePool object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_pool_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_pool ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_pool"
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/watch/namespaces/{namespace}/virtualmachinepools'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_pool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_pool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachinePreference object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_preference(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_preference_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachinePreference object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_preference_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_preference ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_preference"
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinepreferences'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_preference",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_preference\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineRestore object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_restore(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_restore_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineRestore object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_restore_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_restore ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_restore"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinerestores'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_restore",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_restore\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineSnapshot object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_snapshot(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_snapshot_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineSnapshot object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_snapshot_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_snapshot ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_snapshot"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshots'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_snapshot",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_snapshot\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineSnapshotContent object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_namespaced_virtual_machine_snapshot_content(namespace, opts = {})
      data, _status_code, _headers = watch_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, opts)
      data
    end

    # Watch a VirtualMachineSnapshotContent object.
    # @param namespace [String] Object name and auth scope, such as for teams and projects
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_namespaced_virtual_machine_snapshot_content_with_http_info(namespace, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_namespaced_virtual_machine_snapshot_content ...'
      end
      # verify the required parameter 'namespace' is set
      if @api_client.config.client_side_validation && namespace.nil?
        fail ArgumentError, "Missing the required parameter 'namespace' when calling DefaultApi.watch_namespaced_virtual_machine_snapshot_content"
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshotcontents'.sub('{' + 'namespace' + '}', CGI.escape(namespace.to_s))

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_namespaced_virtual_machine_snapshot_content",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_namespaced_virtual_machine_snapshot_content\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineCloneList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_clone_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_clone_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineCloneList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_clone_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_clone_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/clone.kubevirt.io/v1beta1/watch/virtualmachineclones'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_clone_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_clone_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineClusterInstancetypeList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_cluster_instancetype_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_cluster_instancetype_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineClusterInstancetypeList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_cluster_instancetype_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_cluster_instancetype_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_cluster_instancetype_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_cluster_instancetype_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineClusterPreferenceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_cluster_preference_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_cluster_preference_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineClusterPreferenceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_cluster_preference_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_cluster_preference_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterpreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_cluster_preference_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_cluster_preference_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineExportList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_export_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_export_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineExportList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_export_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_export_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/export.kubevirt.io/v1beta1/watch/virtualmachineexports'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_export_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_export_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstanceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_instance_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_instance_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineInstanceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_instance_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_instance_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/virtualmachineinstances'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_instance_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_instance_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstanceMigrationList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_instance_migration_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_instance_migration_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineInstanceMigrationList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_instance_migration_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_instance_migration_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/virtualmachineinstancemigrations'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_instance_migration_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_instance_migration_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstancePresetList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_instance_preset_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_instance_preset_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineInstancePresetList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_instance_preset_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_instance_preset_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/virtualmachineinstancepresets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_instance_preset_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_instance_preset_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstanceReplicaSetList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_instance_replica_set_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_instance_replica_set_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineInstanceReplicaSetList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_instance_replica_set_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_instance_replica_set_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/virtualmachineinstancereplicasets'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_instance_replica_set_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_instance_replica_set_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineInstancetypeList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_instancetype_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_instancetype_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineInstancetypeList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_instancetype_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_instancetype_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineinstancetypes'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_instancetype_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_instancetype_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/kubevirt.io/v1/watch/virtualmachines'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachinePoolList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_pool_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_pool_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachinePoolList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_pool_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_pool_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/pool.kubevirt.io/v1alpha1/watch/virtualmachinepools'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_pool_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_pool_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachinePreferenceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_preference_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_preference_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachinePreferenceList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_preference_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_preference_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachinepreferences'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_preference_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_preference_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineRestoreList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_restore_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_restore_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineRestoreList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_restore_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_restore_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinerestores'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_restore_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_restore_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineSnapshotContentList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_snapshot_content_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_snapshot_content_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineSnapshotContentList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_snapshot_content_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_snapshot_content_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshotcontents'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_snapshot_content_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_snapshot_content_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Watch a VirtualMachineSnapshotList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [K8sIoApimachineryPkgApisMetaV1WatchEvent]
    def watch_virtual_machine_snapshot_list_for_all_namespaces(opts = {})
      data, _status_code, _headers = watch_virtual_machine_snapshot_list_for_all_namespaces_with_http_info(opts)
      data
    end

    # Watch a VirtualMachineSnapshotList object.
    # @param [Hash] opts the optional parameters
    # @option opts [String] :continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
    # @option opts [String] :field_selector A selector to restrict the list of returned objects by their fields. Defaults to everything.
    # @option opts [Boolean] :include_uninitialized If true, partially initialized resources are included in the response.
    # @option opts [String] :label_selector A selector to restrict the list of returned objects by their labels. Defaults to everything
    # @option opts [Integer] :limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
    # @option opts [String] :resource_version When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
    # @option opts [Integer] :timeout_seconds TimeoutSeconds for the list/watch call.
    # @option opts [Boolean] :watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
    # @return [Array<(K8sIoApimachineryPkgApisMetaV1WatchEvent, Integer, Hash)>] K8sIoApimachineryPkgApisMetaV1WatchEvent data, response status code and response headers
    def watch_virtual_machine_snapshot_list_for_all_namespaces_with_http_info(opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: DefaultApi.watch_virtual_machine_snapshot_list_for_all_namespaces ...'
      end
      # resource path
      local_var_path = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshots'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'continue'] = opts[:'continue'] if !opts[:'continue'].nil?
      query_params[:'fieldSelector'] = opts[:'field_selector'] if !opts[:'field_selector'].nil?
      query_params[:'includeUninitialized'] = opts[:'include_uninitialized'] if !opts[:'include_uninitialized'].nil?
      query_params[:'labelSelector'] = opts[:'label_selector'] if !opts[:'label_selector'].nil?
      query_params[:'limit'] = opts[:'limit'] if !opts[:'limit'].nil?
      query_params[:'resourceVersion'] = opts[:'resource_version'] if !opts[:'resource_version'].nil?
      query_params[:'timeoutSeconds'] = opts[:'timeout_seconds'] if !opts[:'timeout_seconds'].nil?
      query_params[:'watch'] = opts[:'watch'] if !opts[:'watch'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json']) unless header_params['Accept']

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'K8sIoApimachineryPkgApisMetaV1WatchEvent'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"DefaultApi.watch_virtual_machine_snapshot_list_for_all_namespaces",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: DefaultApi#watch_virtual_machine_snapshot_list_for_all_namespaces\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
